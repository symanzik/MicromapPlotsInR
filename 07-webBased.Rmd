# Web-based Linked Micromap Plots (via Shiny) {#Ch7}

\chapterauthor{Marcus W. Beck}

Web-based interactive linked micromaps were first developed in the late 1990s. Early examples included visualizing hazardous air pollutant data using the Graphics Production Library [@SACWWW1999] and use of micromaps by the National Cancer Institute to visualize long-term cancer data [@Bell06]. These early attempts primarily used Java-based web technologies to combine micromap visualization tools with online functionality.  Since then, the development of R packages to create web-based applications has allowed new opportunities to visualize and share micromaps online. This chapter will introduce the reader to the creation of linked micromap plots via the R **shiny**\index{R packages!shiny} package [@Chang21]. Core concepts of creating shiny applications will be discussed, including an example that demonstrates a minimal working shiny application with the the **micromap**\index{R Packages!micromap} package [@PaOl2015; @Beck2016].   

## The Need for Web Applications {#Ch7-Introduction}

The ability to develop and host content in an online framework has obvious benefits for research and data-intensive applications.  Reaching new audiences and creating a more immersive experience with interactive functionality can improve understanding beyond text descriptions in technical reports or research articles.  This is especially important when research products have intended applications for non-technical audiences or to simply facilitate sharing of ideas among colleagues, such as for applied environmental (e.g., Chapter \@ref(Ch11)) or medical (e.g., Chapter \@ref(Ch12)) fields.  Web-based applications can greatly improve technology transfer from the research community to practitioners, collaborators, or other stakeholders that may not need to fully understand the technical details of an underlying application, but require robust tools built on quality science to make informed decisions.

In this context, a web-based application (web app or dashboard, hereafter) can have two fundamental roles, where the primary goal of each is to increase understanding of concepts or results from research products or data.  The first and most common use is creating a web app to support an existing or otherwise finalized research product.  Simple examples include developing an application to share results as supplemental information from a research article, creating a web page to synthesize and distill large, publicly available datasets, or using a web application for prioritizing how decisions are made with limited resources.  In the latter case, these may also be generically called decision support tools.  The second, and more under-utilized role of web apps is as intermediate tools that can enhance the research or exploratory analysis process.  For many of the reasons that web apps can improve delivery of science to decision-makers or to inform the public, web apps can also benefit the research community by improving collaboration among colleagues.  We encourage readers to appreciate and understand how web apps can have benefits at different stages of data analysis process, not just as a final product. 

The concepts and tools presented in this chapter can apply equally well to the two use cases above.  In addition to understanding the theory of building web apps with micromaps, additional considerations include how the application is hosted online for access by others and what steps are made to ensure the application is maintained into the future.  A detailed discussion of these concepts is beyond the scope of this chapter, but examples and resources are provided to allow the reader to understand their importance and how to further build on the concepts presented herein.  We cover the basics of developing a shiny application, but refer the reader specifically to @Wickham21 and @Sievert20 for a more comprehensive introduction to using shiny in a web-based framework.   

## Existing Examples of Micromap Web Applications {#Ch7-ExistingWebApps}

* Graphics Production Library [@SACWWW1999]: Figure
* National Cancer Institute [@Bell06], discussed in @Pickle15; Figure
* https://evjones.shinyapps.io/FreshwaterProbMonEDA/
     * This is a shiny app to support an annual report from Virginia DEQ for their freshwater probabilistic monitoring program, see email from 3/9/22	
     * Repo: https://github.com/EmmaVJones/ProbDash/tree/master/app
     * Integrated report driving the app (2022, not published yet): https://github.com/EmmaVJones/FreshwaterProbMonIntegratedReports/tree/main/2022ProbChapter
     * 2020 chapter here: https://www.deq.virginia.gov/home/showpublisheddocument/4309/637461491336170000
See email from Emma on 3/15 explaining why the app was developed - it helped them explore their data (emphasis on second sub-bullet for first bullet above)
* Another example from one of Juergen’s students, currently not hosted online: https://github.com/asa-stat-computing-and-graphics/COST-DataExpo-2019/tree/master/HousingAffordability

## Shiny as an Open Source Tool for Web Applications {#Ch7-Shiny}

### What is Shiny?

The R **shiny**\index{R Packages!shiny} package [@Chang21;@Wickham21] allows a developer to create web applications entirely in the R framework. Shiny can exposes existing R scripts to a web browser to allow anybody to access underlying functionality outside of R and the local environment of a personal computer. Shiny is commonly used to 1) communicate complex workflows to a non-technical audience with informative visualizations and interactive components, 2) share analysis output easily with colleagues without having to walk them through details of a script, and 3) help inform understanding of an analysis by creating a user interface to quickly evaluate data.  Because linked micromaps can be easily created in R using the **micromap**\index{R Packages!micromap} or **micromapST**\index{R Packages!micromapST} packages, creating web apps with shiny is a simple extension that can greatly improve understanding of data.   

There are many advantages to using Shiny over other platforms for creating web applications. The primary advantage is the ability to create rich web content entirely using R.  There is no need to have a detailed understanding of web programming, such as HTML, CSS, or JavaScript. However, shiny leverages this broader suite of web programming tools so that they are available for use should a developer have the need to expand an application's utilities beyond the core features within shiny. More simply, shiny can be used as a web interface for any R workflow. This means that any custom analysis or graphic created by an R user can be can be fully integrated into a web app, unlike other platforms that may have rigid templates where functionality is sacrificed for ease of use.

Understanding shiny can be challenging at first because it introduces a new way of thinking about code. "Simple" R scripts are run linearly, being read from top to bottom in a conventional analysis workflow. The script is written, the code is sourced to the R console, and results or objects are saved in the environment of the current R session after running the script.  A shiny app runs from an R script, but instead of executing code linearly, it uses **reactive** programming that detects when an input is changed on the application, runs the minimal amount of code that uses that input, then updates the output as needed. So, rather than running linearly, the script has interconnected components that share pieces of information that are executed as needed to produce the results.

Reactivity can be daunting at first because it requires the developer to think about which pieces of code require inputs from other pieces and how that information is used to create output. This is not fundamentally different from writing functions in R and creating a shiny application should be straightforward if a developer is comfortable with functional programming [@Wickham19]. Reactivity can be conceptualized by the building blocks of a Shiny app. Every Shiny app has the following:

* User interface (UI): Includes all inputs and outputs, as well as the appearance of the dashboard. In this context, "output" means the final product (e.g. a plot, table, etc.) that is placed in the user interface, but created by processing inputs sent to the server. In web-speak, this is the front end.
* Server: The guts or engine of how the inputs are used to create the outputs. This is where the working parts of the analysis are contained. The server can be as simple or as complicated as needed for an application. In web-speak, this is the back end.

The `ui` and `server` components can be contained in an R script, as follows:

```{r, eval = FALSE}
library(shiny)
ui <- fluidPage()
server <- function(input, output){}
shinyApp(ui = ui, server = server)
```

In RStudio, the application can be run clicking the "Run App" button at the top right of the source window or sending the code to the R console (Figure \@ref(fig:Ch8-shiny-code)).  

```{r Ch8-shiny-code, fig.cap = 'A minimal working shiny application in RStudio showing code for the user interface and server.  The application can be run in RStudio by selecting "Run App".', echo = FALSE, out.width = '100%'}
knitr::include_graphics('img/Ch8-shiny-code.PNG')
```

The above application will open locally, either through a local port opened by RStudio or in a web browser depending on the user options in `shinyApp()`.  In this example, an empty screen appears because the application currently does nothing and it is only accessible to the user in the current R session.  Building a more functional shiny application only requires adding code to the server and user interface.  Making the application accessible to others is described in section \@ref(Ch7-shiny-online).  

The example above can be expanded to demonstrate how code within the server and user interface might look in practice.  The application below takes random samples from a normal distribution and creates a histogram using base R (Figure \@ref(fig:Ch8-shiny-histogram)).  The user interface determines how many random samples are used to create the plot. To make a shiny app, the components required for inputs and outputs must be identified by the developer to determine where they are placed in the code. The input is what a user can modify (the sample size) and the output is the plot. Inputs/outputs go in the `ui` object. The `server` takes the inputs, produces the content for the output, and then sends the results back to the `ui`. Placing these components into the template is as follows: 

```{r, eval = FALSE}
library(shiny)

ui <- fluidPage(
  numericInput(inputId = 'n', label = 'Sample size', value = 50),
  plotOutput('myplot')
)

server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}

shinyApp(ui = ui, server = server)
```

```{r Ch8-shiny-histogram, fig.cap = 'A minimal working shiny application with additional components in the server and user interface that produces a histogram and options to select the sample size.', echo = FALSE, out.width = '100%'}
knitr::include_graphics('img/Ch8-shiny-histogram.PNG')
```

Understanding what happens in the application each time a different sample size is selected by a user is useful to understand reactivity and how the application is coded.  The reactivity of the running application follows these steps (Figure \@ref(fig:Ch8-shiny-flow)):

1. The `input` value `n` (chosen by the developer) from the `ui` is sent to the `server`, seen as `input$n`. 
1. The `dat` object is created as a random sample with size `n` and then a histogram is created as reactive output with `renderPlot`
1. The plot output named `myplot` (chosen by the developer) is appended to the `output` list of objects
1. The plot is then rendered on the `ui` side using `plotOutput` by referencing the `myplot` name from the `output` object. 

```{r Ch8-shiny-flow, fig.cap = 'A representation of reactivity each time the user input is changed to select a different sample size for the histogram.', echo = FALSE, out.width = '100%'}
knitr::include_graphics('img/Ch8-shiny-flow.png')
```

There are some general rules and concepts about Shiny reactivity that are shown here that apply to most Shiny applications.  

* All input objects are defined in the `ui` object, given a name inside the input function and then referenced in the `server` file by `input$name` (`input$n` in this case). 
    ```{r, eval = F}
    numericInput(inputId = 'n', label = 'Sample size', value = 50)
    ```
* All output objects to use in the `ui` object are created in the `server` object by assigning a "rendered" object to the `output` object by `output$name` (`output$myplot` in this case).
    ```{r, eval = F}
    output$myplot <- renderPlot({
      dat <- rnorm(input$n)
      hist(dat)
    })
    ```
* The `ui` file controls where and when the output is rendered, typically using a function named `fooOutput()` (`foo` meaning generic, e.g., `plot`, `table`, etc.) that has a complementary reactive function named `renderFoo()` in the `server` file.
    ```{r, eval = F}
    plotOutput('myplot')
    ```
* The `ui` file can be declared with a function (`fluidPage()` here as one type of layout) with at least two inputs (one input, one output) separated by commas. 
* The `server` file can be declared with the `server()` function, where the input is evaluated as a standalone group of operations with the curly braces `{}`.

All shiny applications use these concepts to create rich, interactive content that is accessible in a web browser.  Expanding on these concepts allows a developer to create more involved and useful applications, such as creating custom micromap plots and options to allow a user to explore patterns more easily than writing custom R code in a conventional script.     

* Layout options: fluidPage, sidebar, flexdashboard, runtime Shiny with Rmarkdown
* Extension via additional web-based tools: htmlwidgets, plotly, leaflet, etc.

### Minimal Micromap Example 

* Basic example using the _USstates_\index{Datasets!USstates} dataset and the **micromap**\index{R Packages!micromap} package [@PaOl2015; @Beck2016]
* General structure via GitHub page: Figure
* Dependencies and data I/O
* UI elements: Figure
* Server backend: Figure

```{r Ch8-shiny-example, fig.cap = 'A minimal working shiny application using the micromap package.', out.width = '100%', echo = FALSE}
knitr::include_graphics('img/Ch8-shiny-example.PNG')
```

### Getting Shiny Online {#Ch7-shiny-online}

* Local vs online
* Use of GitHub for app code and permanency via Zenodo
* Shinyapps.io/RStudio Connect
* Open source Shiny Server 
* Docker containers
* Choosing a license

## Summary and Further Reading {#Ch7-Summary}

* Fundamentals of user interface design, out of scope but why they’re important to consider, engaging end users in design
* Shiny best practices [@Saia22]: modularity [@Fay21], functions, profiling/performance, etc.
* Shiny pros/cons, alternative web platforms
* Revisit value of web-based applications
* Changing landscape of web platforms

\printbibliography[segment=\therefsegment,heading=subbibliography]

