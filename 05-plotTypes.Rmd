# Adding New Plot Types to Linked Micromap Plots (such as Arrow Plots, Line Charts, and Scatterplots) {#Ch5}


\chapterauthor{Sarah Schwartz, J{\"u}rgen Symanzik}


The primary graph types in the statistical panels that are supported by 
the micromap R package are dot plots, dot plots with confidence intervals, 
bar charts, and bar charts with confidence intervals. 
The reader will learn how to add new plot types to the repertoire of plot types, 
starting with arrow plots that show differences of two variables 
and scatterplots for two quantitative variables. 


## Introduction {#Ch5-Introduction}


As a reminder, see Chapter \@ref(Ch1) for general style requirements
for our `Micromap Plots in R` book. In particular, please do the following:

- Introduce meaningful labels for the sections, figures, and tables in your chapter.

- Create index entries for all R packages (such as the **micromap**\index{R Packages!micromap} R package)
and for all datasets (such as the _USstates_\index{Datasets!USstates} and _edPov_\index{Datasets!edPov} datasets)
that are used in your chapter.

- Include references for R packages and publications related to your chapter,
such as for the **micromap**\index{R Packages!micromap} [@PaOl2015] and 
**micromapST**\index{R Packages!micromapST} [@CP2015CRAN] R packages
and some micromap articles, book chapters, and books [@Carr2001;@SC2008;@CP2010].

- Also create index entries for main topics such as
linked micromap plots,\index{Linked micromap plot}
conditioned choropleth maps,\index{Conditioned choropleth map}
perceptual group,\index{Perceptual group}
color blindness,\index{Color blindness},
and quantile-quantile plot.\index{Quantile-quantile plot}


## Outline {#Ch5-Outline}


- overview of graph types that are part of the micromap R package

panel.types (required) - a vector specifying the panels of the plot. Note:
each `panel.type` (e.g. `map`, `labels`, `dot_cl`, etc.) is the name of a
function that will be called to create that panel. Therefore a user can
create a new panel type (e.g. `new.graph.type`) and the mmplot function
will automatically go look for and call that function just by changing the
entry here. See the section `Creating a New Panel Type`.

`panel.types` from Chapter \@ref(Ch2):
`dot_legend`, `labels`, `dot`, `map`,
`box_summary`, `dot_cl`.

also `bar_cl` from vignette

Existing build functions from https://github.com/USEPA/micromap/blob/master/R/PanelBuilding.r

`labels_build`, `bar_build`, `bar_cl_build`, `box_summary_build`, `dot_build`,
`dot_cl_build`, `ranks_build`.


Figure \@ref(fig:Ch5-defaultplottypes) shows one linked micromap plot\index{Linked micromap plot}
with the all pre-defined plot types of the **micromap**\index{R Packages!micromap} R package [@PaOl2015]. This figure is an extension of 
Figures \@ref(fig:Ch2-refining2WV) and \@ref(fig:Ch2-refining2WVsf) from 
Chapter \@ref(Ch2) that previously dealt with the 
_WV\_Watershed_\index{Datasets!WV\_Watershed} dataset.

There are 41 variables in the underlying data frame.
Similar to Chapter \@ref(Ch2) we will focus on the specific conductance variables
in the following linked micromap plots.\index{Linked micromap plot}

Variable names beginning with an uppercase letter, e.g., `Cond_med`, `Cond_LCB95`,
`Cond_UCB95`, are the population estimates, representing the median,
the lower 95% confidence bound, and the upper 95% confidence bound of a variable
(here, specific conductance) in each of the 25 watersheds, respectively.
These variables will be used for the construction of 
dotplots,\index{Dotplot}
dotplots with confidence bounds,\index{Dotplot with confidence bounds}
bar charts,\index{Bar chart} and
bar charts with confidence bounds.\index{Bar chart with confidence bounds}

Variable names starting with a lowercase letter, e.g., 
`cond_min`, `condq1`, `cond_med1`, `cond_q3`, `cond_max`,
are the descriptive statistics, representing the minimum, first quartile, median,
third quartile, and maximum of a variable (here, specific conductance) in each of the 25 watersheds, respectively.
These will be used for the construction of boxplots\index{Boxplot}.

The main purpose of the linked micromap plot\index{Linked micromap plot} 
shown in Figure \@ref(fig:Ch5-defaultplottypes) is to introduce 
all pre-defined panel and plot types of the **micromap**\index{R Packages!micromap} R package.
Therefore, we have omitted a meaningful header for all columns
in this figure and rather titled each column with the type of the information
shown in that column and the corrsponding entry for the `panel.types` list.
We have also further shortened the abbreviations for the subregions
shown in this linked micromap plot.\index{Linked micromap plot}
Readers interested in the full names of these subregions are
referred to Section \@ref(Ch2-RefiningWV).
Also, from a practical perspective, it makes little sense to include
dotplots,\index{Dotplot}
dotplots with confidence bounds,\index{Dotplot with confidence bounds}
bar charts,\index{Bar chart} and
bar charts with confidence bounds\index{Bar chart with confidence bounds}
of the same statistical variable in one figure. Typically,
just a dotplot with confidence bounds\index{Dotplot with confidence bounds}
or a bar chart with confidence bounds\index{Bar chart with confidence bounds}
would have been sufficient to show the underlying statistical data.


(ref:Ch5-defaultplottypes-cap) Linked micromap plot,\index{Linked micromap plot} based on the West Virginia watershed dataset, that shows all pre-defined plot types of the **micromap**\index{R Packages!micromap} R package [@PaOl2015].


```{r Ch5-defaultplottypes, fig.cap = '(ref:Ch5-defaultplottypes-cap)', fig.width = 7, fig.height = 7}
library(micromap)

wv_watershed_sf <- sf::st_read(
  dsn = "data/WV_Watershed/RandomWatershed2_stats_smooth.shp",
  quiet = TRUE
)

wv_watershed_sf$short_name <- as.factor(wv_watershed_sf$Random_Wat)

wv_watershed_short <- list(
  "SPotom" = "South Branch Potomac",
  "NPotom" = "North Branch Potomac",
  "Cacapo" = "Cacapon/Shenandoah Hardy",
  "Potom" = "Potomac Direct Drains/Shenandoah Jefferson",
  "UNew" = "Upper New/James",
  "Tygart" = "Tygart Valley",
  "WFork" = "West Fork",
  "Monong" = "Monongahela/Dunkard",
  "Cheat" = "Cheat/Youghiogheny",
  "UOhio" = "Upper Ohio North/Upper Ohio South",
  "MOhioN" = "Middle Ohio North",
  "MOhioS" = "Middle Ohio South",
  "LKana" = "Little Kanawha",
  "Greenb" = "Greenbrier",
  "LNew" = "Lower New",
  "Gauley" = "Gauley",
  "UKana" = "Upper Kanawha",
  "Elk" = "Elk",
  "LKana" = "Lower Kanawha",
  "Coal" = "Coal",
  "UGuya" = "Upper Guyandotte",
  "LGuya" = "Lower Guyandotte",
  "TugFork" = "Tug Fork",
  "BigSan" = "Big Sandy/Lower Ohio",
  "Twelvep" = "Twelvepole"
)

levels(wv_watershed_sf$short_name) <- wv_watershed_short

mmplot(
  map.data = wv_watershed_sf,
  panel.types = c(
    "dot_legend",
    "ranks",
    "labels",
    "dot",
    "dot_cl",
    "bar",
    "bar_cl",
    "box_summary",
    "map"
  ),
  panel.data = list(
    NA,
    NA,
    "short_name",
    "Cond_med",
    list("Cond_med", "Cond_LCB95", "Cond_UCB95"),
    "Cond_med",
    list("Cond_med", "Cond_LCB95", "Cond_UCB95"),
    list("cond_min", "condq1", "cond_med1", "condq3", "cond_max"),
    NA
  ),
  ord.by = "Cond_med",
  rev.ord = TRUE,
  grouping = 5,
  plot.pGrp.spacing = 1.2,
  colors = RColorBrewer::brewer.pal(n = 5, name = "YlGnBu")[5:1],
  panel.att = list(
    list(
      1,
      header = "Symbol\n(dot_legend)",
      panel.width = 5.5,
      point.type = 15,
      point.size = 0.9,
      point.border = TRUE,
      xaxis.labels.size = 0.8,
      right.margin = 0.4
    ),
    list(
      2,
      header = "Rank\n(ranks)",
      panel.width = 0.8,
      align = "center",
      text.size = 0.2,
      xaxis.labels.size = 0.8,
      right.margin = 0.4
    ),
    list(
      3,
      header = "Name\n(labels)",
      panel.width = 0.8,
      align = "left",
      text.size = 0.75,
      xaxis.labels.size = 0.8
    ),
    list(
      4,
      header = "Dotplot\n(dot)",
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(0, 250, 500),
      xaxis.labels = list(0, 250, 500),
      xaxis.labels.size = 0.8,
      xaxis.title = "[\u03BCS/cm]",
      left.margin = -0.5,
      right.margin = 0.3
    ),
    list(
      5,
      header = "Dotplot & CI\n(dot_cl)",
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(0, 250, 500, 750),
      xaxis.labels = list(0, 250, 500, 750),
      xaxis.labels.size = 0.8,
      xaxis.title = "[\u03BCS/cm]",
      left.margin = -0.5,
      right.margin = 0.3
    ),
    list(
      6,
      header = "Barchart\n(bar)",
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(0, 250, 500),
      xaxis.labels = list(0, 250, 500),
      xaxis.labels.size = 0.8,
      xaxis.title = "[\u03BCS/cm]",
      left.margin = -0.5,
      right.margin = 0.3
    ),
    list(
      7,
      header = "Barchart & CI\n(bar_cl)",
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(0, 250, 500, 750),
      xaxis.labels = list(0, 250, 500, 750),
      xaxis.labels.size = 0.8,
      xaxis.title = "[\u03BCS/cm]",
      left.margin = -0.5,
      right.margin = 0.3
    ),
    list(
      8,
      header = "Boxplot\n(box_summary)",
      graph.bgcolor = "lightgray",
      graph.bar.size = 0.7,
      xaxis.ticks = c(0, 1000, 2000, 3000, 4000, 5000),
      xaxis.labels = c(0, 1, 2, 3, 4, 5),
      xaxis.labels.size = 0.8,
      xaxis.title = "[1,000 \u03BCS/cm]",
      panel.width = 1.2,
      left.margin = -0.5,
      right.margin = 0.3
    ),
    list(
      9,
      header = "Maps\n(map)",
      inactive.border.color = gray(0.7),
      inactive.border.size = 1.5,
      xaxis.labels.size = 0.8
    )
  )
)
```


- general principles of adding new graph types

Examples \@ref(Ch5-Example2) and \@ref(Ch5-Example3)
have been adapted from @SDWPM2014 where they have been introduced
originally.


## Example 1: Adding Vignette Example {#Ch5-Example1}


```{r Ch5-vignettechart, fig.cap = 'Arrow plot from vignette.', fig.width = 7, fig.height = 9}
library(micromap)
library(ggplot2)
library(grid)
library(XML)
library(dplyr)

data("USstates")
statePolys <- create_map_table(USstates, IDcolumn = "ST")

data(lungMort)
myStats <- lungMort
head(myStats)

myStats <- subset(myStats, !StateAb == "DC")

myNewStats <- create_DF_rank(myStats, ord.by = "Rate_00", group = 5)
head(myNewStats)

ggplot(myNewStats) +
  geom_segment(
    aes(
      x = Rate_95,
      y = -pGrpOrd,
      xend = Rate_00,
      yend = -pGrpOrd,
      colour = factor(color)
    ),
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  facet_grid(pGrp ~ .,
    scales = "free_y"
  ) +
  scale_colour_manual(
    values = c("red", "orange", "green", "blue", "purple"),
    guide = "none"
  )

myAtts <- sample_att()
myNumber <- 1
myAtts$colors <- c("red", "orange", "green", "blue", "purple")
myAtts[[myNumber]]$panel.data <- c("Rate_95", "Rate_00")

myColors <- myAtts$colors
# pulls color out of the plot level
# section of the "myAtts" attributes list

myColumns <- myAtts[[myNumber]]$panel.data
# looks in the panel level section numbered
# "myNumber" of the "myAtts" attributes list

myNewStats$data1 <- myNewStats[, myColumns[1]]
myNewStats$data2 <- myNewStats[, myColumns[2]]
myPanel <- ggplot(myNewStats) +
  geom_segment(
    aes(
      x = data1,
      y = -pGrpOrd,
      xend = data2,
      yend = -pGrpOrd,
      colour = factor(color)
    ),
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  facet_grid(pGrp ~ .) +
  scale_colour_manual(
    values = myColors,
    guide = "none"
  )
myPanel

assimilatePlot(myPanel, myNumber, myAtts)

arrow_plot_build <- function(myPanel, myNumber, myNewStats, myAtts) {
  myColors <- myAtts$colors
  myColumns <- myAtts[[myNumber]]$panel.data
  myNewStats$data1 <- myNewStats[, myColumns[1]]
  myNewStats$data2 <- myNewStats[, myColumns[2]]
  myPanel <- ggplot(myNewStats) +
    geom_segment(
      aes(
        x = data1,
        y = -pGrpOrd,
        xend = data2,
        yend = -pGrpOrd,
        colour = factor(color)
      ),
      arrow = arrow(length = unit(0.1, "cm"))
    ) +
    facet_grid(pGrp ~ .) +
    scale_colour_manual(
      values = myColors,
      guide = "none"
    )
  myPanel <- assimilatePlot(myPanel, myNumber, myAtts)
}
myPanel

arrow_plot_build <- function(myPanel, myNumber, myNewStats, myAtts) {
  myColors <- myAtts$colors
  myColumns <- myAtts[[myNumber]]$panel.data
  myNewStats$data1 <- myNewStats[, myColumns[1]]
  myNewStats$data2 <- myNewStats[, myColumns[2]]
  myNewStats <- alterForMedian(myNewStats, myAtts)
  myPanel <- ggplot(myNewStats) +
    geom_segment(
      aes(
        x = data1,
        y = -pGrpOrd,
        xend = data2,
        yend = -pGrpOrd,
        colour = factor(color)
      ),
      arrow = arrow(length = unit(0.1, "cm"))
    ) +
    facet_grid(pGrp ~ .,
      space = "free",
      scales = "free_y"
    ) +
    scale_colour_manual(
      values = myColors,
      guide = "none"
    )
  myPanel <- assimilatePlot(myPanel, myNumber, myAtts)
}
myPanel


# print(myAtts)

myPanelAtts <- standard_att()
myPanelAtts <- append(
  myPanelAtts,
  list(line.width = 1, tip.length = 1)
)

arrow_plot_att <- function() {
  myPanelAtts <- standard_att()
  myPanelAtts <- append(
    myPanelAtts,
    list(line.width = 1, tip.length = 1)
  )
}


arrow_plot_build <- function(myPanel, myNumber, myNewStats, myAtts) {
  myColors <- myAtts$colors
  myColumns <- myAtts[[myNumber]]$panel.data
  myLineWidth <- myAtts[[myNumber]]$line.width
  # Again, note that these are stored in the panel level section of the
  myTipLength <- myAtts[[myNumber]]$tip.length # attributes object
  myNewStats$data1 <- myNewStats[, myColumns[1]]
  myNewStats$data2 <- myNewStats[, myColumns[2]]
  myNewStats <- alterForMedian(myNewStats, myAtts)
  myPanel <- ggplot(myNewStats) +
    geom_segment(
      aes(
        x = data1,
        y = -pGrpOrd,
        xend = data2,
        yend = -pGrpOrd,
        colour = factor(color)
      ),
      arrow = arrow(length = unit(0.1 * myTipLength, "cm")),
      size = myLineWidth
    ) +
    facet_grid(pGrp ~ .,
      space = "free",
      scales = "free_y"
    ) +
    scale_colour_manual(
      values = myColors,
      guide = "none"
    )
  myPanel <- assimilatePlot(myPanel, myNumber, myAtts)
}
myPanel


mmplot(
  stat.data = myStats,
  map.data = statePolys,
  panel.types = c("map", "labels", "arrow_plot"),
  panel.data = list(NA, "State", list("Rate_95", "Rate_00")),
  ord.by = "Rate_00",
  grouping = 5,
  map.link = c("StateAb", "ID"),
  panel.att =
    list(
      list(
        3,
        line.width = 1.25,
        tip.length = 1.5
      )
    )
)

data(lungMort)
myStats <- lungMort


mmplot(
  stat.data = myStats,
  map.data = statePolys,
  panel.types = c("map", "dot_legend", "labels", "dot_cl", "arrow_plot"),
  panel.data = list(
    NA,
    "points",
    "State",
    list("Rate_00", "Lower_00", "Upper_00"),
    list("Rate_95", "Rate_00")
  ),
  ord.by = "Rate_00",
  grouping = 5,
  median.row = TRUE,
  map.link = c("StateAb", "ID"),
  plot.height = 10,
  colors = c("red", "orange", "green", "blue", "purple"),
  panel.att = list(
    list(
      1,
      header = "Light Gray Means\nHighlighted Above",
      map.all = TRUE,
      fill.regions = "two ended",
      inactive.fill = "lightgray",
      inactive.border.color = gray(.7),
      inactive.border.size = 2,
      panel.width = 1
    ),
    list(
      2,
      point.type = 20,
      point.border = TRUE
    ),
    list(
      3,
      header = "U.S. \nStates ",
      panel.width = .8,
      align = "left",
      text.size = .9
    ),
    list(
      4,
      header = "State 2000\n Rate and 95% CI",
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(20, 30, 40, 50),
      xaxis.labels = list(20, 30, 40, 50),
      xaxis.title = "Deaths per 100,000"
    ),
    list(
      5,
      header = "State Rate Change\n 1995-99 to 2000-04",
      line.width = 1.25,
      tip.length = 1.5,
      graph.bgcolor = "lightgray",
      xaxis.ticks = list(20, 30, 40, 50),
      xaxis.labels = list(20, 30, 40, 50),
      xaxis.title = "Deaths per 100,000"
    )
  )
)
```


## Example 2: Adding Bar Charts as a New Plot Type {#Ch5-Example2}


```{r Ch5-barchartArgentina, fig.cap = 'Bar chart.', fig.width = 7, fig.height = 9}
ArgShapefile <- as_Spatial(st_read("data/ARG_adm/ARG_adm1.shp"))

names(ArgShapefile)
ArgShapefile$NAME_1

ArgShapefileThin <- st_as_sf(ArgShapefile) %>%
  st_simplify(
    dTolerance = 1000,
    preserveTopology = TRUE
  ) %>%
  as_Spatial()

# manipulate population dataset
Argfile <- "data/List of Argentine provinces by population - Wikipedia, the free encyclopedia.htm"
Argtable <- readHTMLTable(Argfile)[[1]]


Argtable <- Argtable[, -3]
Argtable <- apply(Argtable, 2, function(x) gsub(".*00000", "", x))
Argtable <- apply(Argtable, 2, function(x) gsub(",", "", x))
Argtable <- as.data.frame(Argtable)
Argtable[, 1] <- as.character(Argtable[, 1])
Argtable[, 2] <- as.character(Argtable[, 2])
Argtable[, 3] <- as.numeric(as.character(Argtable[, 3]))
Argtable[, 4] <- as.numeric(as.character(Argtable[, 4]))
Argtable[4, 2] <- "Ciudad de Buenos Aires"
provincematch <- gregexpr("\\<[[:alpha:][:space:]]*", Argtable[, 2])
Argtable[, 2] <- unlist(regmatches(Argtable[, 2], provincematch))
colnames(Argtable) <- c("Rank", "provinces", "2010 Population", "2001 Population")
Argtable[, "change"] <- Argtable[, 3] - Argtable[, 4]
provinces <- as.character(sort(Argtable[, 2]))
ArgShapefileThin@data <- cbind(ArgShapefileThin@data, provinces)
Argtable[, 3:5] <- sapply(Argtable[, 3:5], function(x) x / 1000000)
Argtable[, "ratio"] <- Argtable[, 3] / Argtable[, 4]

# arg1_1 - figure not used in accompanying article

ArgPolys <- create_map_table(ArgShapefileThin, "provinces")

myTable <- create_DF_rank(Argtable,
  ord.by = "2010 Population",
  group = c(5, 5, 4, 5, 5), rev.ord = TRUE
)
myTable[11:14, "pGrpOrd"] <- myTable[11:14, "pGrpOrd"] + 0.5
myAtts <- sample_att()
myNumber <- 1
myAtts$colors <- c("red", "orange", "green", "blue", "purple")
myAtts[[myNumber]]$panel.data <- "change"
myColors <- myAtts$colors
myColumns <- myAtts[[myNumber]]$panel.data
myTable$data1 <- myTable[, myColumns]
myPanel <- ggplot(myTable) +
  geom_segment(aes(
    x = 0, y = -pGrpOrd, xend = data1, yend = -pGrpOrd,
    colour = factor(color)
  )) +
  facet_grid(pGrp ~ .) +
  scale_colour_manual(
    values = myColors,
    guide = "none"
  )
assimilatePlot(myPanel, myNumber, myAtts)

myPanelAtts <- standard_att()
myPanelAtts <- append(myPanelAtts, list(line.width = 4))

bar_plot_att <- function() {
  myPanelAtts <- standard_att()
  myPanelAtts <- append(myPanelAtts, list(line.width = 4))
}

bar_plot_build <- function(myPanel, myNumber, myNewStats, myAtts) {
  myColors <- myAtts$colors
  myColumns <- myAtts[[myNumber]]$panel.data
  myLineWidth <- myAtts[[myNumber]]$line.width
  myTipLength <- myAtts[[myNumber]]$tip.length
  myTable$data1 <- myNewStats[, myColumns]
  myPanel <- ggplot(myTable) +
    geom_segment(
      aes(
        x = 0, y = -pGrpOrd,
        xend = data1, yend = -pGrpOrd,
        colour = factor(color)
      ),
      size = myLineWidth
    ) +
    facet_grid(pGrp ~ ., space = "free", scales = "free_y") +
    scale_colour_manual(values = myColors, guide = "none")
  myPanel <- assimilatePlot(myPanel, myNumber, myAtts)
}

Argtable$ProvinceTemp <- as.character(Argtable$provinces)

# arg1_2 - Figure 3
mmplot(
  stat.data = Argtable,
  map.data = ArgPolys,
  panel.types = c(
    "map", "dot_legend", "labels",
    "dot", "bar_plot", "dot"
  ),
  panel.data = list(
    NA, "points", "ProvinceTemp",
    "2010 Population", "change", "ratio"
  ),
  ord.by = "2010 Population",
  rev.ord = TRUE,
  grouping = c(5, 5, 4, 5, 5),
  vertical.align = "center",
  map.link = c("provinces", "ID"),
  colors = brewer.pal(6, "Greys")[6:1],
  map.color2 = gray(0.95),
  plot.width = 10,
  panel.att = list(
    list(
      1,
      header = "Maps",
      panel.width = 0.6,
      active.border.color = "black",
      active.border.size = 0.5,
      inactive.border.color = gray(0.7),
      inactive.border.size = 0.5
    ),
    list(
      2,
      point.size = 0.8
    ),
    list(
      3,
      header = "Provinces",
      align = "left",
      text.size = 1.0,
      panel.width = 1.5
    ),
    list(
      4,
      header = "2010 Population",
      graph.bgcolor = gray(0.95),
      xaxis.ticks = list(0, 4, 8, 12, 16),
      xaxis.labels = list(0, 4, 8, 12, 16),
      xaxis.title = "People (Millions)",
      panel.width = 1.8
    ),
    list(
      5,
      header = "Population Increase\nfrom 2001 to 2010",
      graph.bgcolor = gray(0.95),
      xaxis.ticks = list(0, 0.9, 1.8),
      xaxis.labels = list(0, 0.9, 1.8),
      xaxis.title = "People (Millions)",
      panel.width = 1.8
    ),
    list(
      6,
      header = "Ratio of 2010 Population\nto 2001 Population",
      graph.bgcolor = gray(0.95),
      xaxis.ticks = list(1, 1.2, 1.4),
      xaxis.labels = list(1, 1.2, 1.4),
      panel.width = 1.8
    )
  )
)
```


## Example 3: Adding Arrow Plots for Differences as a New Plot Type {#Ch5-Example3}


```{r Ch5-arrowplotBrazil, fig.cap = 'Arrow plot for differences.', fig.width = 7, fig.height = 9}
library(micromap)
library(ggplot2)
library(XML)
library(dplyr)


BraShapefile <- sf::as_Spatial(sf::st_read("data/BRA_adm/BRA_adm1.shp"))

BraShapefileThin <- st_as_sf(BraShapefile) %>%
  st_simplify(
    dTolerance = 1000,
    preserveTopology = TRUE
  ) %>%
  as_Spatial()

brazil4 <- BraShapefileThin

Brafile <- "data/States of Brazil - Wikipedia, the free encyclopedia.htm"
Bratable <- readHTMLTable(Brafile)[[12]]

Bratable <- apply(Bratable, 2, function(x) gsub("[(].*", "", x))
Bratable <- apply(Bratable, 2, function(x) gsub(".*00000", "", x))
Bratable <- apply(Bratable, 2, function(x) gsub("[,]", "", x))
Bratable <- apply(Bratable, 2, function(x) gsub("[%]", "", x))
Bratable[, 12] <- substr(Bratable[, 12], 1, nchar(Bratable[, 12]) - 1)
Bratable <- as.data.frame(Bratable)
Bratable <- data.frame(
  Bratable[, 1:4],
  sapply(Bratable[, 5:13], function(x) as.numeric(as.character(x)))
)
State <- as.character(sort(Bratable[, 2]))

StateReordered <- State[c(16, 18:27, 15, 17)]
State[15:27] <- StateReordered

brazil4@data <- cbind(brazil4@data, State)
Bratable[, 6] <- Bratable[, 6] / 1000000

BrazilPolys <- create_map_table(brazil4, "State")


# bra2 - Figure 6

Brafile2 <- "data/List of Brazilian states by murder rate - Wikipedia, the free encyclopedia.htm"
Bratable2 <- readHTMLTable(Brafile2)[[1]]

Bratable2 <- Bratable2[-c(8, 18, 23, 27, 32, 33), ]
Bratable2[, 2:13] <- sapply(Bratable2[, 2:13], function(x) as.numeric(as.character(x)))
Bratable2[, 1] <- as.character(Bratable2[, 1])
Bratable2[, 1] <- substring(Bratable2[, 1], 2)
Bratable2[, "change"] <- Bratable2[, 12] - Bratable2[, 2]
Bratable2[, "zero"] <- 0
Bratable2 <- Bratable2[order(Bratable2[, 1]), ]
myTable <- create_DF_rank(Bratable2,
  ord.by = "2008",
  group = c(4, 4, 4, 3, 4, 4, 4), rev.ord = TRUE
)
myTable[13:15, "pGrpOrd"] <- myTable[13:15, "pGrpOrd"] + 0.6
names(Bratable2)[1] <- "states"
names(myTable)[2] <- "states"

myAtts <- sample_att()
myNumber <- 1
myAtts$colors <- c("red", "orange", "green", "blue")
myAtts[[myNumber]]$panel.data <- c("zero", "change")
myColors <- myAtts$colors
myColumns <- myAtts[[myNumber]]$panel.data
myTable$data1 <- myTable[, myColumns[1]]
myTable$data2 <- myTable[, myColumns[2]]
myPanel <- ggplot(myTable) +
  geom_segment(
    aes(
      x = data1, y = -pGrpOrd,
      xend = data2, yend = -pGrpOrd, colour = factor(color)
    ),
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  facet_grid(pGrp ~ .) +
  scale_colour_manual(values = myColors, guide = "none")

assimilatePlot(myPanel, myNumber, myAtts)
myPanelAtts <- standard_att()
myPanelAtts <- append(
  myPanelAtts,
  list(line.width = 1, tip.length = 1)
)

arrow_plot_att <- function() {
  myPanelAtts <- standard_att()
  myPanelAtts <- append(
    myPanelAtts,
    list(line.width = 1, tip.length = 1)
  )
}

arrow_plot_build <- function(myPanel, myNumber, myNewStats, myAtts) {
  myColors <- myAtts$colors
  myColumns <- myAtts[[myNumber]]$panel.data
  myLineWidth <- myAtts[[myNumber]]$line.width
  myTipLength <- myAtts[[myNumber]]$tip.length
  myTable$data1 <- myNewStats[, myColumns[1]]
  myTable$data2 <- myNewStats[, myColumns[2]]
  myPanel <- ggplot(myTable) +
    geom_segment(
      aes(
        x = data1, y = -pGrpOrd,
        xend = data2, yend = -pGrpOrd,
        colour = factor(color)
      ),
      arrow = arrow(length = unit(0.1 * myTipLength, "cm")),
      size = myLineWidth
    ) +
    facet_grid(pGrp ~ ., space = "free", scales = "free_y") +
    scale_colour_manual(values = myColors, guide = "none")
  myPanel <- assimilatePlot(myPanel, myNumber, myAtts)
}

Bratable2$StateMod <- as.character(Bratable2$states)

mmplot(
  stat.data = Bratable2,
  map.data = BrazilPolys,
  panel.types = c("map", "dot_legend", "labels", "dot", "arrow_plot"),
  panel.data = list(NA, "points", "StateMod", "1998", c("zero", "change")),
  ord.by = "1998",
  rev.ord = TRUE,
  grouping = c(4, 4, 4, 3, 4, 4, 4),
  vertical.align = "center",
  map.link = c("states", "ID"),
  colors = brewer.pal(5, "Greys")[5:1],
  map.color2 = gray(0.9),
  panel.att = list(
    list(
      1,
      header = "Maps",
      panel.width = 0.8,
      active.border.color = "black",
      active.border.size = 0.5,
      inactive.border.color = gray(0.7),
      inactive.border.size = 0.5
    ),
    list(
      2,
      point.size = 0.8
    ),
    list(
      3,
      header = "States",
      align = "left",
      text.size = 0.9,
      panel.width = 1.3
    ),
    list(
      4,
      header = "Murder Rate\nin 1998",
      point.type = 20,
      point.size = 1.4,
      graph.bgcolor = gray(0.9),
      xaxis.ticks = list(0, 20, 40, 60),
      xaxis.labels = list(0, 20, 40, 60),
      xaxis.title = "Percent (%)",
      panel.width = 1.8
    ),
    list(
      5,
      header = "Murder Rate Change\nfrom 1998 to 2008",
      graph.bgcolor = gray(0.9),
      xaxis.title = "Percentage Points",
      panel.width = 1.8
    )
  )
)
```


## Example 4: Adding Scatterplots as a New Plot Type {#Ch5-Example4}

NOTE: Error in this code chunk after upgrade to ggplot2 4.0.0
See here for further discussion of the error and possible fixes
  https://github.com/tidyverse/ggplot2/issues/6507


```{r Ch5-scatterplot, fig.cap = 'Scatterplot.', fig.width = 7, fig.height = 9,eval=FALSE}
### load packages
library(micromap)
library(ggplot2)
library(grid)
# library(rgdal)

### read code to print at end
# read_chunk("scatdot_build.R")
# read_chunk("scatdot_att.R")
# read_chunk("axis_opts_grid.R")

### source the functions in to the global environment
# source("scatdot_build.R")

scatdot_build <- function(pl, p, DF, att) {
  # define the data to use
  DF$tmp.data1 <- DF[, unlist(att[[p]]$panel.data[1])]
  DF$tmp.data2 <- DF[, unlist(att[[p]]$panel.data[2])]

  DF <- alterForMedian(DF, att)

  # set the x and y axis limits
  # start with the ranges of the data
  tmp.limsx <- range(DF[, unlist(att[[p]]$panel.data[1])], na.rm = T)
  tmp.limsy <- range(DF[, unlist(att[[p]]$panel.data[2])], na.rm = T)

  # expand if the ticks cover a wider range
  if (any(!is.na(att[[p]]$xaxis.ticks))) {
    tmp.limsx <- range(c(tmp.limsx, att[[p]]$xaxis.ticks))
  }
  if (any(!is.na(att[[p]]$yaxis.ticks))) {
    tmp.limsy <- range(c(tmp.limsy, att[[p]]$yaxis.ticks))
  }

  # expand a bit more so things aren't bumping agains the edges
  tmp.limsx <- tmp.limsx + c(-1, 1) * diff(tmp.limsx) * 0.05
  tmp.limsy <- tmp.limsy + c(-1, 1) * diff(tmp.limsy) * 0.05

  # ensure the range isn't zero
  if (diff(tmp.limsx) == 0) {
    tmp.limsx <- tmp.limsx + c(-0.5, 0.5)
  }
  if (diff(tmp.limsy) == 0) {
    tmp.limsy <- tmp.limsy + c(-0.5, 0.5)
  }

  # median row margins, if needed
  tmp.median.limsy <- NULL

  if (att$median.row) {
    if (!any(DF$median)) {
      DF <- rbind(DF, transform(DF[1, ],
        pGrpOrd  = 1,
        pGrp     = att$m.pGrp,
        median   = TRUE,
        rank     = "",
        tmp.data = median(DF$tmp.data)
      ))
    }
    tmp.median.limsy <- c(-0.5, -1.5)
  }

  # create a new dataframe to hold the full set of points
  # 'n' for every group, except the median
  if (att[[p]]$annotate.all) {
    fullDF <- tmpDF <- DF
    list <- unique(DF$pGrp[!DF$median])
    for (j in 1:length(list)) {
      tmpDF$pGrp <- list[j]
      tmpDF$color <- att$grouping + 2
      tmpDF$median <- FALSE
      fullDF <- merge(fullDF, tmpDF, all = TRUE)
    }
  } else {
    fullDF <- DF
  }

  fullDF$ann <- (fullDF$color == att$grouping + 2) + 1


  if (att$median.row) {
    if (fullDF[fullDF$median, ]$pGrp %in% 1:max(fullDF$pGrp)) {
      fullDF[fullDF$median, ]$pGrp <- fullDF[fullDF$median, ]$pGrp - 1
      fullDF[fullDF$median, ]$color <- att$grouping + 1

      copyMed <- fullDF[fullDF$median, ]
      copyMed$pGrp <- copyMed$pGrp + 2

      fullDF <- merge(fullDF, copyMed, all = TRUE)
    } else {
      fullDF <- fullDF[!fullDF$median, ]
    }
  }

  att$colors <- c(
    att$colors[1:att$grouping],
    att[[p]]$median.point.color
  )


  # start the panel
  pl <- ggplot(fullDF)

  # plot points
  pl <- pl + geom_point(aes(
    x = tmp.data1,
    y = tmp.data2,
    color = as.factor(color),
    size = as.factor(ann),
    pch = as.factor(ann),
    alpha = as.factor(ann)
  ))

  # use the correct colors, no legend needed
  pl <- pl + scale_colour_manual(
    values = c(
      att$colors,
      att[[p]]$annotate.color
    ),
    guide = "none"
  )
  pl <- pl + scale_size_manual(
    values = c(
      att[[p]]$point.size * 2,
      att[[p]]$annotate.size * 2
    ),
    guide = "none"
  )
  pl <- pl + scale_shape_manual(
    values = c(
      att[[p]]$point.type,
      att[[p]]$annotate.type
    ),
    guide = "none"
  )
  pl <- pl + scale_alpha_manual(
    values = c(
      att[[p]]$point.alpha,
      att[[p]]$annotate.alpha
    ),
    guide = "none"
  )

  # use facet to split up the groups
  pl <- pl + facet_grid(pGrp ~ .,
    space = "free",
    scales = "free_y",
    drop = TRUE
  )

  # let the 3 package functions alter some basics
  pl <- plot_opts(p, pl, att)
  pl <- graph_opts(p, pl, att)
  pl <- axis_opts_grid(p, pl, att,
    limsx = tmp.limsx,
    limsy = c(tmp.limsy, tmp.median.limsy),
    border = att[[p]]$border
  )
  pl
}

# source("scatdot_att.R")

scatdot_att <- function(show = FALSE) {
  tmp.att <- list(
    panel.header = NA,
    panel.header.size = as.numeric(1),
    panel.header.color = "black",
    panel.header.face = "plain",
    panel.header.font = NA,
    panel.header.lineheight = as.numeric(1),
    panel.width = as.numeric(1),
    panel.bgcolor = NA,
    left.margin = NA,
    right.margin = NA,
    panel.margins = c(1, -0.25, 1, -1.5),
    graph.grid.major = as.logical(TRUE),
    graph.grid.major.lty = as.numeric(1),
    graph.grid.major.col = "dark gray",
    graph.grid.minor = as.logical(TRUE),
    graph.grid.minor.lty = as.numeric(3),
    graph.grid.minor.col = "light gray",
    graph.bgcolor = NA,
    graph.border.color = "black",
    xaxis.title = "",
    xaxis.ticks = NA,
    xaxis.labels = NA,
    xaxis.line.display = as.logical(TRUE),
    xaxis.ticks.display = as.logical(TRUE),
    xaxis.text.display = as.logical(TRUE),
    xaxis.labels.size = as.numeric(1),
    xaxis.labels.angle = NULL,
    xaxis.labels.hjust = NULL,
    xaxis.labels.vjust = NULL,
    xaxis.title.size = as.numeric(1),
    xaxis.title.color = "black",
    xaxis.title.face = "plain",
    xaxis.title.font = NA,
    xaxis.title.lineheight = as.numeric(1),
    yaxis.title = "",
    yaxis.ticks = NA,
    yaxis.labels = NA,
    yaxis.line.display = as.logical(TRUE),
    yaxis.ticks.display = as.logical(TRUE),
    yaxis.text.display = as.logical(TRUE),
    yaxis.labels.size = as.numeric(1),
    yaxis.labels.angle = NULL,
    yaxis.labels.hjust = NULL,
    yaxis.labels.vjust = NULL,
    yaxis.title.size = as.numeric(1),
    yaxis.title.color = "black",
    yaxis.title.face = "plain",
    yaxis.title.font = NA,
    yaxis.title.lineheight = as.numeric(1),
    panel.margins = c(1, -0.25, 1, 1.5),
    point.size = as.numeric(2),
    point.type = as.numeric(19),
    point.alpha = as.numeric(0.9),
    median.line = as.logical(FALSE),
    median.line.col = "black",
    median.line.typ = "longdash",
    median.line.size = as.numeric(1),
    median.point.color = "dark gray",
    border = as.logical(TRUE),
    graph.margin = as.numeric(1),
    annotate.all = as.logical(TRUE),
    annotate.size = as.numeric(0.5),
    annotate.color = "gray",
    annotate.type = as.numeric(19),
    annotate.alpha = as.numeric(1)
  )
  if (show) {
    tmp.att
  } else {
    invisible(tmp.att)
  }
}

# source("axis_opts_grid.R")

axis_opts_grid <- function(i, pl, a,
                           limsx = NA,
                           limsy = NA,
                           border = TRUE,
                           expx = FALSE) {
  # if missing a background color specification, default to white
  bgcolor <- ifelse(!is.na(a[[i]]$panel.bgcolor),
    a[[i]]$panel.bgcolor,
    "white"
  )

  # there is only one axis label size
  label.size <- as.numeric(max(all_atts(a, "xaxis.labels.size"))) * 10


  ### --------------------------------------------------------- ###
  ### x-axis title
  ### --------------------------------------------------------- ###

  # start off with everything set clean
  x.breaks <- x.labels <- x.limits <- x.expand <- FALSE
  xstr.title <- "''"

  if (!all(is.na(all_atts(a, "xaxis.title")))) {
    tmp.size <- max(as.numeric(all_atts(
      a,
      "xaxis.title.size"
    ))) * 8
    tmp.lineheight <- as.numeric(all_atts(
      a,
      "xaxis.title.lineheight"
    ))
    tmp.lineheight <- tmp.lineheight[which.max(abs(tmp.lineheight - 1))]

    tmp.titles <- lapply(
      all_atts(a, "xaxis.title"),
      function(t) {
        if (is.na(t) | t == "") {
          t <- " "
        } else {
          t
        }
      }
    )
    tmp.title <- tmp.titles[[i]]
    ns <- max(unlist(lapply(
      tmp.titles,
      function(x) {
        length(strsplit(x, "\n")[[1]])
      }
    ))) -
      length(strsplit(tmp.title, "\n")[[1]])
    if (ns > 0) {
      tmp.title <- paste(tmp.title, rep(" \n ", ns), sep = "")
    }
    xstr.title <- paste("'", tmp.title, "'", sep = "")

    pl <- pl +
      theme(
        axis.title.x =
          element_text(
            family = a[[i]]$xaxis.title.font,
            face = a[[i]]$xaxis.title.face,
            colour = a[[i]]$xaxis.title.color,
            size = tmp.size,
            lineheight = tmp.lineheight
          )
      )
  }

  if (all(is.na(all_atts(a, "xaxis.title")))) {
    pl <- pl + theme(axis.title.x = element_blank())
  }

  ### --------------------------------------------------------- ###

  if (!any(is.na(limsx))) {
    x.limits <- TRUE
  }
  if (!expx) {
    x.expand <- TRUE
    xstr.expand <- as.character(", expand=c(0,0)")
  }

  xstr.limits <- as.character(paste(
    "c(",
    min(limsx),
    ",",
    max(limsx),
    ")"
  ))
  xstr.limits <- paste(", limits=", xstr.limits)


  ### --------------------------------------------------------- ###
  ### Axis line display
  ### --------------------------------------------------------- ###

  if (!a[[i]]$xaxis.line.display & !a[[i]]$yaxis.line.display) {
    pl <- pl + theme(axis.line = element_line(colour = bgcolor))
  } else {
    pl <- pl + theme(axis.line = element_line(colour = "black"))
  }

  pl <- pl + theme(axis.ticks = element_blank())


  ### --------------------------------------------------------- ###
  ### x-axis text display & text, labels, ticks
  ### --------------------------------------------------------- ###

  if (!any(all_attsb(a, "xaxis.text.display"))) {
    pl <- pl + theme(axis.text.x = element_blank())
  } else if (!a[[i]]$xaxis.text.display) {
    pl <- pl + theme(axis.text.x = element_text(
      colour = bgcolor,
      size = label.size
    ))
  } else if (!is.na(unlist(a[[i]]$xaxis.labels)[1]) &
    !is.na(unlist(a[[i]]$xaxis.ticks)[1])) {
    tmpTheme <- "theme(axis.text.x = element_text(size=label.size"
    if (!is.null(a[[i]]$xaxis.labels.angle)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        angle = ",
        a[[i]]$xaxis.labels.angle
      )
    }
    if (!is.null(a[[i]]$xaxis.labels.hjust)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        hjust =",
        a[[i]]$xaxis.labels.hjust
      )
    }
    if (!is.null(a[[i]]$xaxis.labels.vjust)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        vjust =",
        a[[i]]$xaxis.labels.vjust
      )
    }
    tmpTheme <- paste(tmpTheme, "))")

    pl <- pl + eval(parse(text = tmpTheme))

    x.breaks <- x.labels <- TRUE
    xstr.breaks <- paste(",
                         breaks=c(",
      make.string(a[[i]]$xaxis.ticks),
      ")",
      sep = ""
    )
    xstr.labels <- paste(",
                         labels=c(",
      make.string(a[[i]]$xaxis.labels),
      ")",
      sep = ""
    )
  } else if (!is.na(unlist(a[[i]]$xaxis.labels)[1]) |
    !is.na(unlist(a[[i]]$xaxis.ticks)[1])) {
    print("Warning: both axis labels AND tick location must be specified")
  }



  ### --------------------------------------------------------- ###
  ### scale_x_continuous
  ### --------------------------------------------------------- ###

  xstr <- paste("scale_x_continuous(", xstr.title)
  if (x.expand) {
    xstr <- paste(xstr, xstr.expand)
  }
  if (x.breaks) {
    xstr <- paste(xstr, xstr.breaks)
  }
  if (x.labels) {
    xstr <- paste(xstr, xstr.labels)
  }
  if (x.limits) {
    xstr <- paste(xstr, xstr.limits)
  }
  xstr <- paste(xstr, ")")

  pl <- pl + eval(parse(text = xstr))




  ### --------------------------------------------------------- ###
  ### y-axis title
  ### --------------------------------------------------------- ###

  # start off with everything set clean
  y.breaks <- y.labels <- y.limits <- y.expand <- FALSE
  ystr.title <- "''"
  if (!all(is.na(all_atts(a, "yaxis.title")))) {
    tmp.size <- max(as.numeric(all_atts(
      a,
      "yaxis.title.size"
    ))) * 8
    tmp.lineheight <- as.numeric(all_atts(
      a,
      "yaxis.title.lineheight"
    ))
    tmp.lineheight <- tmp.lineheight[which.max(abs(tmp.lineheight - 1))]

    tmp.titles <- lapply(
      all_atts(a, "yaxis.title"),
      function(t) {
        if (is.na(t) | t == "") {
          t <- " "
        } else {
          t
        }
      }
    )
    tmp.title <- tmp.titles[[i]]
    ns <- max(unlist(lapply(
      tmp.titles,
      function(y) {
        length(strsplit(y, "\n")[[1]])
      }
    ))) -
      length(strsplit(tmp.title, "\n")[[1]])
    if (ns > 0) {
      tmp.title <- paste(tmp.title, rep(" \n ", ns), sep = "")
    }
    ystr.title <- paste("'", tmp.title, "'", sep = "")

    pl <- pl +
      theme(
        axis.title.y =
          element_text(
            family = a[[i]]$yaxis.title.font,
            face = a[[i]]$yaxis.title.face,
            colour = a[[i]]$yaxis.title.color,
            size = tmp.size,
            lineheight = tmp.lineheight
          )
      )
  }
  if (all(is.na(all_atts(a, "yaxis.title")))) {
    pl <- pl + theme(axis.title.y = element_blank())
  }

  ### --------------------------------------------------------- ###

  if (!any(is.na(limsy))) {
    y.limits <- TRUE
  }
  if (!expx) {
    y.expand <- TRUE
    ystr.expand <- as.character(", expand=c(0,0)")
  }
  ystr.limits <- as.character(paste(
    "c(",
    min(limsy),
    ",",
    max(limsy),
    ")"
  ))
  ystr.limits <- paste(", limits=", ystr.limits)


  ### --------------------------------------------------------- ###
  ### axis line display
  ### --------------------------------------------------------- ###

  if (!a[[i]]$xaxis.line.display & !a[[i]]$yaxis.line.display) {
    pl <- pl + theme(axis.line = element_line(colour = bgcolor))
  } else {
    pl <- pl + theme(axis.line = element_line(colour = "black"))
  }

  pl <- pl + theme(axis.ticks = element_blank())


  ### --------------------------------------------------------- ###
  ### y-axis text display & text, labels, ticks
  ### --------------------------------------------------------- ###


  if (!any(all_attsb(a, "yaxis.text.display"))) {
    pl <- pl + theme(axis.text.y = element_blank())
  } else if (!a[[i]]$yaxis.text.display) {
    pl <- pl + theme(
      axis.text.y =
        element_text(
          colour = bgcolor,
          size = label.size
        )
    )
  } else if (!is.na(unlist(a[[i]]$yaxis.labels)[1]) &
    !is.na(unlist(a[[i]]$yaxis.ticks)[1])) {
    tmpTheme <- "theme(axis.text.y = element_text(size=label.size"
    if (!is.null(a[[i]]$yaxis.labels.angle)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        angle = ",
        a[[i]]$yaxis.labels.angle
      )
    }
    if (!is.null(a[[i]]$yaxis.labels.hjust)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        hjust =",
        a[[i]]$yaxis.labels.hjust
      )
    }
    if (!is.null(a[[i]]$yaxis.labels.vjust)) {
      tmpTheme <- paste(
        tmpTheme, ",
                        vjust =",
        a[[i]]$yaxis.labels.vjust
      )
    }
    tmpTheme <- paste(tmpTheme, "))")

    pl <- pl + eval(parse(text = tmpTheme))

    y.breaks <- y.labels <- TRUE
    ystr.breaks <- paste(", breaks = c(",
      make.string(a[[i]]$yaxis.ticks),
      ")",
      sep = ""
    )
    ystr.labels <- paste(", labels = c(",
      make.string(a[[i]]$yaxis.labels),
      ")",
      sep = ""
    )
  } else if (!is.na(unlist(a[[i]]$yaxis.labels)[1]) |
    !is.na(unlist(a[[i]]$yaxis.ticks)[1])) {
    print("Warning: both axis labels AND tick location must be specified")
  }



  ### --------------------------------------------------------- ###
  ### scale_y_continuous
  ### --------------------------------------------------------- ###

  ystr <- paste("scale_y_continuous(", ystr.title)
  if (y.expand) {
    ystr <- paste(ystr, ystr.expand)
  }
  if (y.breaks) {
    ystr <- paste(ystr, ystr.breaks)
  }
  if (y.labels) {
    ystr <- paste(ystr, ystr.labels)
  }
  if (y.limits) {
    ystr <- paste(ystr, ystr.limits)
  }
  ystr <- paste(ystr, ")")

  pl <- pl + eval(parse(text = ystr))


  ### --------------------------------------------------------- ###
  ### Grid Lines & vertical gap between scatter plots
  ### --------------------------------------------------------- ###

  # some specific theme items different than the basic
  pl <- pl + theme(
    panel.grid.major =
      element_line(
        linetype =
          a[[i]]$graph.grid.major.lty,
        colour =
          a[[i]]$graph.grid.major.col
      ),
    panel.grid.minor =
      element_line(
        linetype =
          a[[i]]$graph.grid.minor.lty,
        colour =
          a[[i]]$graph.grid.minor.col
      ),
    panel.margin = unit(
      a[[i]]$graph.margin,
      "lines"
    )
  )


  ### --------------------------------------------------------- ###
  ### Grid's border
  ### --------------------------------------------------------- ###

  borderx <- range(limsx) + c(1, -1) * diff(range(limsx)) * 0.001
  bordery <- range(limsy) + c(0, -1) * diff(range(limsy)) * 0.001

  facetNum <- unique(pl$data$pGrp)
  if (a$median.row) {
    facetNum <- facetNum[facetNum != a$m.pGrp]
  }

  tmp.border <- data.frame(
    pGrp = rep(facetNum, each = 2),
    ymin = bordery[1],
    ymax = bordery[2],
    xmin = borderx[1],
    xmax = borderx[2]
  )
  if (border) {
    border.color <- a[[i]]$graph.border.color
  } else {
    border.color <- NA
  }

  # draw a rectange instead of a border
  pl <- pl + geom_rect(
    aes(
      xmin = xmin,
      xmax = xmax,
      ymin = ymin,
      ymax = ymax
    ),
    data = tmp.border,
    colour = border.color,
    fill = NA
  )

  # set the boarder off
  pl <- pl + theme(axis.line = element_blank())

  pl
}

### read in the statistical data
# religion <- read.csv("Main Document-ReligionData.csv",
#                     header = TRUE)

religion <- read.csv(
  file = "data/China_ReligionData.csv",
  header = TRUE
)

### read in the map dta
# ChinaShape <- readOGR("China_Provinces_Thinned",
#                       "ChinaThinned",
#                       verbose = TRUE)

ChinaShapefile <- sf::as_Spatial(sf::st_read("data/China_Shapefiles/export.shp"))

ChinaShapefileThin <- sf::st_read("data/China_Shapefiles/export.shp") %>%
  st_simplify(dTolerance = 2000) %>%
  as_Spatial()

# gIsValid(ChinaShape, byid = TRUE, reason = TRUE)
ChinaPolys <- create_map_table(ChinaShapefileThin, "ename")


# Error: <ggplot2::element_text> object properties are invalid:
# - @family must be <NULL> or <character>, not <logical>

# mmplot(
#   stat.data = religion,
#   map.data = ChinaPolys,
#   panel.types = c(
#     "labels",
#     "dot_legend",
#     "dot",
#     "scatdot",
#     "map"
#   ),
#   panel.data = list(
#     "Province",
#     NA,
#     "Daoism",
#     c("Christianity", "Buddhism"),
#     NA
#   ),
#   ord.by = "Daoism",
#   map.link = c("Province", "ID"),
#   grouping = 5
# )


### set tick mark sequence
Daoism.tick <- seq(from = 0, to = 2000, by = 1000)
Christ.tick <- seq(from = 0, to = 3000, by = 1000)
Buddhi.tick <- seq(from = 0, to = 3000, by = 1000)
Islam.tick <- seq(from = 0, to = 25000, by = 10000)
Total.tick <- seq(from = 0, to = 25000, by = 10000)

Total.tick.less <- seq(from = 0, to = 10000, by = 5000)
Islam.tick.less <- seq(from = 0, to = 4000, by = 1000)


mmplot(
  stat.data = religion,
  map.data = ChinaPolys,
  panel.types = c(
    "labels",
    "dot_legend",
    "dot",
    "scatdot",
    "map"
  ),
  panel.data = list(
    "Province",
    NA,
    "Daoism",
    c("Christianity", "Buddhism"),
    NA
  ),
  ord.by = "Daoism",
  map.link = c("Province", "ID"),
  rev.ord = TRUE,
  grouping = 5,
  median.row = TRUE,
  median.color = "dark gray",
  colors = brewer.pal(5, "RdYlBu"),
  two.ended.maps = TRUE,
  map.all = TRUE,
  map.color2 = "lightgray",
  plot.header = "Religion in China",
  plot.header.size = 2,
  plot.header.color = "black",
  plot.panel.spacing = 0,
  plot.pGrp.spacing = 2,
  panel.att = list(
    list(
      1,
      header = "Provinces",
      panel.width = .5,
      align = "right",
      text.size = 1
    ),
    list(
      2,
      header = "",
      point.type = 20,
      point.size = 2
    ),
    list(
      3,
      header = "Daoism",
      point.type = 20,
      point.size = 2,
      graph.grid.minor = TRUE,
      xaxis.title = "Daoism, in thousands",
      xaxis.ticks = Daoism.tick,
      xaxis.labels = Daoism.tick / 1000
    ),
    list(
      4,
      header = "Christianity vs.Buddhism",
      point.type = 20,
      point.alpha = 0.8,
      left.margin = 1.6,
      xaxis.title = "Christianity, in thousands",
      xaxis.ticks = Christ.tick,
      xaxis.labels = Christ.tick / 1000,
      yaxis.title = "Buddhism, in thousands",
      yaxis.ticks = Buddhi.tick,
      yaxis.labels = Buddhi.tick / 1000,
      graph.margin = 0.5,
      border = TRUE
    ),
    list(
      5,
      header = "Two-ended\nCumulative Maps",
      inactive.border.color = gray(.7),
      inactive.border.size = 1,
      panel.width = 1.2
    )
  )
)


Paired5 <- brewer.pal(5, "Paired")[5:1]
Paired6 <- brewer.pal(6, "Paired")[6:1]
Divergent5 <- brewer.pal(5, "RdYlBu")

### ======================================================================== ###
### Create a plot WITHOUT a median row, but TWO scatdot panels
### ======================================================================== ###

mmplot(
  stat.data = religion[religion$Province != "Xinjiang", ],
  map.data = ChinaPolys,
  panel.types = c(
    "labels",
    "dot_legend",
    "dot",
    "scatdot",
    "scatdot",
    "map"
  ),
  panel.data = list(
    "Province",
    NA,
    "Total",
    c("Christianity", "Buddhism"),
    c("Daoism", "Islam"),
    NA
  ),
  ord.by = "Total",
  map.link = c("Province", "ID"),
  rev.ord = TRUE,
  grouping = 5,
  median.row = FALSE,
  # colors = Divergent5,
  colors = Paired5,
  plot.width = 10,
  plot.height = 10,
  two.ended.maps = TRUE,
  map.all = TRUE,
  map.color2 = "lightgray",
  plot.header = "Religion in China",
  plot.header.size = 2,
  plot.header.color = "black",
  plot.panel.spacing = 0,
  plot.pGrp.spacing = 2,
  panel.att = list(
    list(1,
      header = "Provinces",
      panel.width = .5,
      align = "right",
      text.size = 1
    ),
    list(2,
      header = "",
      point.type = 20,
      point.size = 2
    ),
    list(3,
      header = "Total",
      panel.width = 0.75,
      point.type = 20,
      point.size = 2,
      graph.grid.minor = TRUE,
      xaxis.title = "Total, in thousands",
      xaxis.ticks = Total.tick.less,
      xaxis.labels = Total.tick.less / 1000
    ),
    list(4,
      header = "Christianity vs. Buddhism",
      point.type = 20,
      # point.size = 3,
      point.alpha = 0.95,
      point.border = FALSE,
      left.margin = 1.5,
      # panel.width = 1.5,
      xaxis.title = "Christianity, in thousands",
      xaxis.ticks = Christ.tick,
      xaxis.labels = Christ.tick / 1000,
      yaxis.title = "Buddhism, in thousands",
      yaxis.ticks = Buddhi.tick,
      yaxis.labels = Buddhi.tick / 1000,
      graph.grid.major.col = "dark gray",
      graph.grid.minor.col = "dark gray",
      graph.margin = 0.5
    ),
    list(5,
      header = "Daoism vs. Islam",
      point.type = 20,
      # point.size = 3,
      point.alpha = 0.95,
      point.border = FALSE,
      left.margin = 1.5,
      # panel.width = 1.5,
      xaxis.title = "Daoism, in thousands",
      xaxis.ticks = Daoism.tick,
      xaxis.labels = Daoism.tick / 1000,
      yaxis.title = "Islam, in thousands",
      yaxis.ticks = Islam.tick.less,
      yaxis.labels = Islam.tick.less / 1000,
      graph.grid.major.col = "dark gray",
      graph.grid.minor.col = "dark gray",
      graph.margin = 0.5
    ),
    list(6,
      header = "Two-ended\nCumulative Maps",
      inactive.border.color = gray(.7),
      inactive.border.size = 1,
      panel.width = 1.2
    )
  )
)


### ======================================================================== ###
### Create a plot WITH a median row
### ======================================================================== ###

mmplot(
  stat.data = religion,
  map.data = ChinaPolys,
  panel.types = c(
    "labels",
    "dot_legend",
    "dot",
    "scatdot",
    "map"
  ),
  panel.data = list(
    "Province",
    NA,
    "Daoism",
    c("Christianity", "Buddhism"),
    NA
  ),
  ord.by = "Daoism",
  map.link = c("Province", "ID"),
  rev.ord = TRUE,
  grouping = 5,
  median.row = TRUE,
  colors = Paired5,
  plot.width = 10,
  plot.height = 10,
  two.ended.maps = TRUE,
  map.all = TRUE,
  map.color2 = "lightgray",
  plot.header = "Religion in China",
  plot.header.size = 2,
  plot.header.color = "black",
  plot.panel.spacing = 0,
  plot.pGrp.spacing = 2,
  panel.att = list(
    list(1,
      header = "Provinces",
      panel.width = .5,
      align = "right",
      text.size = 1
    ),
    list(2,
      header = "",
      point.type = 20,
      point.size = 2
    ),
    list(3,
      header = "Daoism",
      point.type = 20,
      point.size = 2,
      graph.grid.minor = TRUE,
      xaxis.title = "Daoism",
      xaxis.ticks = Daoism.tick,
      xaxis.labels = Daoism.tick
    ),
    list(4,
      header = "Christianity vs.Buddhism",
      point.type = 20,
      # point.size = 2.5,
      point.alpha = 0.8,
      point.border = FALSE,
      left.margin = 1.6,
      # panel.width = 1.5,
      xaxis.title = "Christianity, in thousands",
      xaxis.ticks = Christ.tick,
      xaxis.labels = Christ.tick / 1000,
      yaxis.title = "Buddhism, in thousands",
      yaxis.ticks = Buddhi.tick,
      yaxis.labels = Buddhi.tick / 1000,
      graph.grid.major.col = "dark gray",
      graph.grid.minor.col = "dark gray",
      graph.margin = 0.5,
      border = TRUE
    ),
    list(5,
      header = "Two-ended\nCumulative Maps",
      inactive.border.color = gray(.7),
      inactive.border.size = 1,
      panel.width = 1.2
    )
  )
)
```



## Main {#Ch5-Main}


TEXT


## Summary and Further Reading {#Ch5-SummaryFurtherReading}


Introduce cross-references to other chapters, e.g., Chapter \@ref(Ch1) and Chapter \@ref(Ch2),
where related work and further examples can be found in this book that match the content of this
chapter, that follow up on this chapter, or that are a prerequisite of this chapter.

Also, do some scientific literature review here that is specific to your chapter.
Where has this R package been introduced and used before, where have other plot types
or different countries been used in micromaps, what were other applications 
of micromaps that are related to the title and content of your chapter, etc.?


\printbibliography[segment=\therefsegment,heading=subbibliography]
